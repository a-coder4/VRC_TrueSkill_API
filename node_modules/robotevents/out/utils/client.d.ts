import { ErrorResponse, FilterKeys, PathsWithMethod, ResponseObjectMap } from "openapi-typescript-helpers";
import type { Paginated, paths } from "../generated/shim.js";
import { type ClientOptions as OpenAPIClientOptions, type Client as OpenAPIClient, FetchResponse, FetchOptions } from "openapi-fetch";
export type PaginatablePaths = {
    [Path in PathsWithMethod<paths, "get">]: FetchResponse<paths[Path]["get"], unknown, "application/json">["data"] extends Paginated<unknown> | undefined ? Path : never;
}[keyof paths];
export type UnwrappedPaginatedPathTypes = {
    [Path in PathsWithMethod<paths, "get">]: FetchResponse<paths[Path]["get"], unknown, "application/json">["data"] extends Paginated<infer W> | undefined ? W[] : never;
};
export type PaginatedPaths = {
    [Path in PaginatablePaths]: FetchResponse<paths[Path]["get"], unknown, "application/json">["data"] extends Paginated<infer W> | undefined ? {
        get: {
            parameters: paths[Path]["get"]["parameters"];
            requestBody?: paths[Path]["get"]["requestBody"];
            responses: Omit<paths[Path]["get"]["responses"], 200> & {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": W[];
                    };
                };
            };
        };
    } : never;
};
export type ClientCustomMethods = {
    PaginatedGET<Path extends PaginatablePaths, Init extends FetchOptions<FilterKeys<paths[Path], "get">>>(path: Path, init: Init): Promise<FetchResponse<PaginatedPaths[Path]["get"], {}, "application/json">>;
};
export type Client = OpenAPIClient<paths, "application/json"> & ClientCustomMethods;
export type ClientOptions = {
    authorization: {
        token: string;
    };
    request?: OpenAPIClientOptions;
};
export declare function createClient(options: ClientOptions): Client;
export type TransformedFetchResponse<T, K, M extends `${string}/${string}`, N> = {
    data: N;
    error?: never;
    response: Response;
} | {
    data?: never;
    error: ErrorResponse<ResponseObjectMap<T>, M>;
    response: Response;
};
export declare function transformResponse<T, K, M extends `${string}/${string}`, N>(response: Promise<FetchResponse<T, K, M>>, transform: (data: NonNullable<FetchResponse<T, K, M>["data"]>, response: FetchResponse<T, K, M>) => N | Promise<N>): Promise<TransformedFetchResponse<T, K, M, N>>;
