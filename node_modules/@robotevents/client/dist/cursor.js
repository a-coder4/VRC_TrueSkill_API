export class Cursor {
    async forEach(iterator) {
        while (await this.hasNext()) {
            iterator(await this.next());
        }
    }
    filter(predicate) {
        return new FilteredCursor(this, predicate);
    }
    map(transform) {
        return new TransformedCursor(this, transform);
    }
    flatMap(transform) {
        return new NestedCursor(this.map(transform));
    }
    async toArray() {
        const values = [];
        await this.forEach(value => values.push(value));
        return values;
    }
}
export class FilteredCursor extends Cursor {
    constructor(cursor, filterFn) {
        super();
        Object.defineProperty(this, "cursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cursor
        });
        Object.defineProperty(this, "filterFn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: filterFn
        });
        Object.defineProperty(this, "nextValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    async hasNext() {
        if (this.nextValue !== undefined) {
            return true;
        }
        while (await this.cursor.hasNext()) {
            const value = await this.cursor.next();
            if (this.filterFn(value)) {
                this.nextValue = value;
                return true;
            }
        }
        return false;
    }
    async next() {
        let value = this.nextValue;
        if (value !== undefined) {
            this.nextValue = undefined;
            return value;
        }
        do {
            value = await this.cursor.next();
        } while (!this.filterFn(value));
        return value;
    }
}
export class TransformedCursor extends Cursor {
    constructor(cursor, transform) {
        super();
        Object.defineProperty(this, "cursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cursor
        });
        Object.defineProperty(this, "transform", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transform
        });
    }
    async hasNext() {
        return await this.cursor.hasNext();
    }
    async next() {
        return this.transform(await this.cursor.next());
    }
    map(transform) {
        const oldTransform = this.transform;
        return new TransformedCursor(this.cursor, (value) => transform(oldTransform(value)));
    }
}
export class NestedCursor extends Cursor {
    constructor(cursor) {
        super();
        Object.defineProperty(this, "cursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cursor
        });
        Object.defineProperty(this, "innerCursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    async hasNext() {
        while ((await this.cursor.hasNext()) &&
            !(await this.innerCursor?.hasNext())) {
            this.innerCursor = await this.cursor.next();
        }
        return this.innerCursor?.hasNext() ?? false;
    }
    async next() {
        if (!this.innerCursor) {
            throw new Error('No elements remaining in cursor');
        }
        return this.innerCursor.next();
    }
}
export class ArrayCursor extends Cursor {
    constructor(values) {
        super();
        Object.defineProperty(this, "values", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: values
        });
    }
    async hasNext() {
        return this.values.length > 0;
    }
    async next() {
        const next = this.values.shift();
        if (!next) {
            throw new Error('No elements remaining in cursor');
        }
        return next;
    }
    async toArray() {
        return this.values.splice(0);
    }
}
//# sourceMappingURL=cursor.js.map